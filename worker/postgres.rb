dep('postgresql installed'){
  requires 'postgres.managed', 'postgres configured', 'sysctl shared memory configured', 'postgres test users exist'
}

# We may need to authorize this key, it seems to have been removed.
# gpg --keyserver pgpkeys.mit.edu --recv-key  010908312D230C5F
# gpg -a --export 010908312D230C5F | sudo apt-key add -

dep 'postgres.managed', :version do
  version.default('9.1')
  # Assume the installed version if there is one
  version.default!(shell('psql --version').val_for('psql (PostgreSQL)')[/^\d\.\d/]) if which('psql')
  requires 'set.locale'
  requires_when_unmet {
    on :apt, 'ppa'.with('ppa:pitti/postgresql')
  }
  installs {
    via :apt, ["postgresql-#{owner.version}", "libpq-dev"]
    via :brew, "postgresql"
  }
  provides "psql ~> #{version}.0"
end

dep 'postgres access' do
  requires 'postgres.managed', 'user exists'
  met? { !sudo("echo '\\du' | #{which 'psql'}", :as => 'postgres').split("\n").grep(/^\W*\b#{var :username}\b/).empty? }
  meet { sudo "createuser -SdR #{var :username}", :as => 'postgres' }
end

dep('postgres running') {
  met? {
    shell? "ps auwwx | grep postgres"
  }

  meet {
    sudo "service postgresql start"
  }
}

dep('postgres test users exist') {
  requires 'postgres running'

  users = ['rails', 'ubuntu']

  met? {
    users.all? do |user|
      !sudo("echo '\\du' | #{which 'psql'}", :as => 'postgres').split("\n").grep(/^\W*\b#{user}\b/).empty?
    end
  }

  meet {
    users.each do |user|
      unless sudo("echo '\\du' | #{which 'psql'}", :as => 'postgres').split("\n").grep(/^\W*\b#{user}\b/).empty?
        sudo "dropuser --username postgres #{user}", :as => 'postgres'
      end
      sudo "createuser --no-password --superuser #{user}", :as => 'postgres'
    end
  }
}

dep 'pg.gem' do
  requires 'postgres.managed'
  provides []
end

dep 'postgres.ppa' do
  adds 'ppa:pitti/postgresql'
end

dep('postgres configured', :version) {
  version.default!('9.1')

  def postgres_dir
    "/etc/postgresql/#{version}/main"
  end

  def max_connections
   200
  end

  met? {
    shell?("grep 'Generated by babushka' #{postgres_dir}/postgresql.conf", :sudo => true) &&
    shell?("grep 'Generated by babushka' #{postgres_dir}/pg_hba.conf", :sudo => true)
  }

  meet {
    render_erb("postgres/pg_hba.conf.erb", :to => "#{postgres_dir}/pg_hba.conf", :sudo => true, :perms => '600', :as => 'postgres')
    render_erb("postgres/postgresql.conf.erb", :to => postgres_dir / 'postgresql.conf', :sudo => true, :perms => '600', :as => 'postgres')
    shell("chown postgres:postgres #{postgres_dir}/pg_hba.conf", :sudo => true)
    shell("chown postgres:postgres #{postgres_dir}/postgresql.conf", :sudo => true)
  }

  after {
    log_shell "Restarting postgres", "service postgresql restart", :sudo => true
  }
}

dep('sysctl shared memory configured') {
  met? {
    shell?("grep 'Generated by babushka' /etc/sysctl.d/30-postgresql-shm.conf", :sudo => true)
  }

  meet {
    render_erb "postgres/30-shared-memory.conf.erb", :to => "/etc/sysctl.d/30-postgresql-shm.conf", :sudo => true
    sudo "sysctl -w kernel.shmmax=37085184"
    sudo "sysctl -w kernel.shmall=34680"
  }
}

dep 'dummy unaccenting dictionary installed', :db_name do
  if !db_name.set? && ENV["DATABASE_URL"]
    begin
      uri = URI.parse(ENV["DATABASE_URL"])
    rescue URI::InvalidURIError
      raise "Invalid DATABASE_URL"
    end
    db_name.default! uri.path.split("/")[1]
  end

  met? { shell?("psql #{db_name} -c '\\dF' | grep unaccenting_english_stemmer") }
  meet { shell("psql #{db_name} -c 'create text search configuration public.unaccenting_english_stemmer (copy = pg_catalog.english);'") }
end
